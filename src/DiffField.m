declare type MonArg;

declare attributes MonArg: ExtensionType, Argument;


intrinsic MonomialArg(extType :: MonStgElt, arg :: RngDiffElt) -> MonArg
{
    Create a monomial to be used as an extension over the parent of the
    argument. extType must be one of the string literals "exp" or "log".
}
    require extType eq "exp" or extType eq "log"
        : "Bad Extension Type.";
    require IsAlgebraicDifferentialField(Parent(arg))
        : "arg must come from an algebraic differential field";
    require Derivative(arg) ne 0
        : "arg cannot be a constant";
    M := New(MonArg);
    M`ExtensionType := extType;
    M`Argument := arg;
    return M;
end intrinsic;


intrinsic MonomialType(m :: MonArg) -> MonStgElt
{ Return the type of the monomial }
    return m`ExtensionType;
end intrinsic;


intrinsic MonomialArg(m :: MonArg) -> RngDiffElt
{ Return the argument of the monomial }
    return m`Argument;
end intrinsic;


intrinsic ChangeUnderlyingField(m :: MonArg, F :: RngDiff) -> MonArg
{ Change the underlying field the argument to this monomial comes from }
    require IsCoercible(F, m`Argument)
        : "Monomial argument cannot be coerced to this field";
    return MonomialArg(m`ExtensionType, F ! (m`Argument));
end intrinsic;


intrinsic Print(m :: MonArg)
{ Print m}
    arg := m`Argument;
    if m`ExtensionType eq "log" then
        printf "log(%o)", arg;
    else
        printf "exp(%o)", arg;
    end if;
end intrinsic;


declare type DiffField[DiffFieldElt];

/*
 * BaseField: K(x) where K is the constant field, must be an Algebraic
 *  Differential Field.
 * MonomialTower: The monomials in the current differential field. The last
 *  monomial is the ``separating element" of this field
 * ActualRngDiff: The representation of this field as a RngDiff, generated by
 *  a single call to DifferentialFieldExtension over BaseField.
 */
declare attributes DiffField: MonomialTower, ActualRngDiff;


intrinsic AllTranscendental(to_check :: [MonArg]: known := []) -> Tup
{
    Use the Risch Structure Theorem to check if the given tower of monomials are
    indeed transcendental over their base field.
    Returns the first monomial which is not transcendental and an offending
    linear/ product combination. If no such monomial exists, return the empty
    tuple.
}
    // TODO if there is time
    return <>;
end intrinsic;


function UnsafeDiffField(monomials)
    F := Parent(MonomialArg(monomials[1]));

    G := New(DiffField);
    G`MonomialTower := monomials;

    if #monomials gt 0 then
        P := PolynomialRing(F, #monomials);
        derivs := [];
        for i in [ 1 .. #monomials ] do
            arg := MonomialArg(monomials[i]);
            if MonomialType(monomials[i]) eq "exp" then
                derivs cat:= [ Derivative(arg) * P.i ];
            else
                derivs cat:= [ Derivative(arg) / arg ];
            end if;
        end for;
        
        G`ActualRngDiff := DifferentialFieldExtension(ChangeUniverse(derivs, P));
    else
        G`ActualRngDiff := F;
    end if;
    return G;
end function;


intrinsic DifferentialField(monomials :: [MonArg]) -> DiffField
{
    Construct a differential field with the given monomial tower, checking that
    each extension is transcendental over the previous.
}

    F := Parent(MonomialArg(monomials[1]));

    require forall{ m : m in monomials | Parent(MonomialArg(m)) cmpeq F }
        : "All monomial arguments must come from the same base ring";
    require IsAlgebraicDifferentialField(F)
        : "Base ring must be an algebraic differential field";

    trans_check := AllTranscendental(monomials);
    require #trans_check eq 0 : Sprintf("MonArg %o is not transcental: %o",
            trans_check[1], trans_check[2]);

    return UnsafeDiffField(monomials);
end intrinsic;


intrinsic Monomials(F :: DiffField) -> SeqEnum
{ Return the monomials generating this field }
    return F`MonomialTower;
end intrinsic;


intrinsic Generators(F :: DiffField) -> SetEnum
{ Return the generators of the differential field }
    return Generators(F`ActualRngDiff);
end intrinsic;


intrinsic ConstantField(F :: DiffField) -> Fld
{ Return the constant field of F }
    return ConstantField(F`ActualRngDiff);
end intrinsic;


intrinsic BaseField(F :: DiffField) -> Rng
{ Return the base field of F }
    return BaseField(F`ActualRngDiff);
end intrinsic;


intrinsic ExtendConstantField(F :: DiffField, C :: Fld) -> DiffField
{ Return a new differential field, with the constant field extended to C }
    G := ConstantFieldExtension(BaseField(F), C); // error checking happens here
    return DifferentialField(
            [ChangeUnderlyingField(m, G) : m in F`MonomialTower]); // shouldn't throw
end intrinsic;


intrinsic MonomialExtension(F :: DiffField, monomials :: [MonArg]) -> DiffField
{
    Return a new differential field which has the monomial extensions of the
    given differential field as well as the new monomial extensions.
}
    require forall{ m : m in monomials | Parent(MonomialArg(m)) cmpeq BaseField(F) }
        : "All new monomials must come from the base field  of the given \
        differential field";

    trans_check := AllTranscendental(monomials: known := F`MonomialTower);
    require #trans_check eq 0 : Sprintf("MonArg %o is not transcental: %o",
            trans_check[1], trans_check[2]);

    // Use unsafe bc potentially expensive to check each new symbol is
    // transcendental again.
    return UnsafeDiffField(F`MonomialTower cat monomials);
end intrinsic;


intrinsic Print(F :: DiffField)
{ Print F }
    printf "Differential field %o with monomial extenstions %o",
        F`ActualRngDiff, F`MonomialTower;
end intrinsic;


// y no work so good? Assigns, but does not then accept assigned names as input.
// Moreover, does not allow inline assignment using <>
intrinsic AssignNames(~F :: DiffField, names :: [MonStgElt])
{ Assign names to the generators of the differential field }
    AssignNames(~(F`ActualRngDiff), names);
end intrinsic;


intrinsic '.'(F :: DiffField, i :: RngIntElt) -> DiffFieldElt
{ Return the ith generator of F }
    return (F`ActualRngDiff).i;
end intrinsic;


/*
 * Parent: must be the DiffField this elt belongs to, NOT the
 *  DiffField`ActualRngDiff.
 * ActualRngDiffElt: The representation of this object as an element of
 *  the parent's ActualRngDiff.
 */
declare attributes DiffFieldElt: Parent, ActualRngDiffElt;


function CreateElement(F, actualDiffElt)
    // Create the element actualDiffElt inside F
    f := New(DiffFieldElt);
    f`Parent := F;
    f`ActualRngDiffElt := actualDiffElt;
    return f;
end function;


intrinsic IsCoercible(F :: DiffField, x :: .) -> BoolElt, .
{
    Return whether x is coercible into F, and the result if so.
}
    rngDiff := F`ActualRngDiff;
    if Type(x) eq DiffFieldElt then
        if x`Parent cmpeq F then
            return true, x;
        elif IsCoercible(x`ActualRngDiffElt, rngDiff) then
            return true, CreateElement(F, rngDiff ! x`ActualRngDiffElt);
        end if;
    elif IsCoercible(rngDiff, x) then
        return true, CreateElement(F, rngDiff ! x);
    end if;
    return false, "coercion failed";
end intrinsic;


intrinsic Print(x :: DiffFieldElt)
{ Print x }
    printf "%o", x`ActualRngDiffElt;
end intrinsic;


intrinsic Parent(x :: DiffFieldElt) -> DiffField
{ Parent of x }
    return x`Parent;
end intrinsic;


intrinsic '+'(x :: DiffFieldElt, y :: DiffFieldElt) -> DiffFieldElt
{ Return x + y }
    F := Parent(x);
    require F cmpeq Parent(y) : "Incompatible arguments";
    return CreateElement(F, x`ActualRngDiffElt + y`ActualRngDiffElt);
end intrinsic;


intrinsic '-'(x :: DiffFieldElt, y :: DiffFieldElt) -> DiffFieldElt
{ Return x - y }
    F := Parent(x);
    require F cmpeq Parent(y) : "Incompatible arguments";
    return CreateElement(F, x`ActualRngDiffElt - y`ActualRngDiffElt);
end intrinsic;


intrinsic '*'(x :: DiffFieldElt, y :: DiffFieldElt) -> DiffFieldElt
{ Return x * y }
    F := Parent(x);
    require F cmpeq Parent(y) : "Incompatible arguments";
    return CreateElement(F, x`ActualRngDiffElt * y`ActualRngDiffElt);
end intrinsic;


intrinsic '/'(x :: DiffFieldElt, y :: DiffFieldElt) -> DiffFieldElt
{ Return x / y }
    F := Parent(x);
    require F cmpeq Parent(y) : "Incompatible arguments";
    return CreateElement(F, x`ActualRngDiffElt / y`ActualRngDiffElt);
end intrinsic;


intrinsic Derivative(x :: DiffFieldElt) -> DiffFieldElt
{ Return the derivative of x }
    return CreateElement(Parent(x), Derivative(x`ActualRngDiffElt));
end intrinsic;
